
#' Generate several random forests with different random number seeds using R.
#'
#' This function generates several random forests for the same data set using different
#' random number seeds. It uses the R package parallelRandomForest
#' \url{https://bitbucket.org/mkuhn/parallelrandomforest}.
#' 
#' @param data data.frame with phenotype and predictor variables
#' @param out.prefix a character string with the prefix of the output files. The function generates two files: <out.prefix>_all_runs.info (errors and minimal importance scores in each run) and <out.prefix>_all_runs_relative.importance (relative variable importance for all variables in each run). If NULL, results will be returned as list.
#' @param no.runs number of forests to be generated
#' @param type type of random forest analysis (must be either 'classification' or 'regression')
#' @param ntree number of trees in each forest
#' @param mtry number of variables selected for each split
#' @param nodesize minimum size of terminal nodes. Note that it should be set to about 10\% of the sample size.
#' @param var.pheno name of column containing phenotype information
#' @param seed random number seed for first forest (additional forests will use <seed> + 1, <seed + 2>, ...)
#' @param no.threads number of threads for generating random forests in parallel mode
#' @param map.file a character string with name of map file (either MAP or BIM format)
#' 
#' @return
#' if out.prefix is not specified, a list with two elements:
#' 
#' info errors and minimal importance scores in each run
#' 
#' var.imp.rel: relative variable importance for all variables in each run
#' 
#' @export

random.forest.runs <- function(data, out.prefix = NULL, type = "classification", ntree, mtry,
                               nodesize, var.pheno, no.runs,
                               seed = 123456, no.threads = 1, map.file = NULL) {

    ## extract input data
    x = data[, setdiff(colnames(data), var.pheno)]
    y = data[, var.pheno]
    if (type == "classification") {
        y = as.factor(y)
    }

    ## change integer class of predictor variables to numeric
    x = apply(x, 2, function(v) {
        if (is.integer(v)) {
            return(as.numeric(v))
        } else {
            return(v)
        }})
    
    set.seed(seed)
    n = nrow(data)
    imp.all = NULL
    info.error = NULL
    for (r in 1:no.runs) {
        print(paste("run", r))

        ## RF
        rf = parallelRandomForest::randomForest(x = x, y = y,
            importance = TRUE,
            ntree = ntree,
            mtry = mtry,
            nodesize = nodesize,
            nthreads = no.threads)
        
        ## importance scores
        imp.all = cbind(imp.all, parallelRandomForest::importance(rf, type = 1, scale = FALSE))

        ## errors
        info.error = rbind(info.error, .calculate.error(rf = rf, 
                                                       true = y,
                                                       train.oob = TRUE))
    }

    ## relative importance scores
    rel.imp.all = .calculate.rel.var.imp(var.imp = imp.all)
    
    info.imp = t(apply(rel.imp.all, 1, quantile, probs = c(0, 0.5), na.rm = TRUE))
    colnames(info.imp) = c("rel_imp_min", "rel_imp_med")

    ## add positional info (if map file is given)
    if (!is.null(map.file)) {
        info.var = read.table(file = map.file, header = FALSE, as.is = TRUE)[, c(2, 1, 4)]
        dimnames(info.var) = list(info.var[, 1], c("varname", "chr", "pos"))
    } else {
        info.var = data.frame(varname = rownames(rel.imp.all), stringsAsFactors = FALSE)
    }

    ## check order of variables
    if (!identical(info.var$varname, rownames(rel.imp.all)) |
        !identical(info.var$varname, rownames(info.imp))) {
        stop("Different order of variable names!")
    }
  
    var.imp.new = data.frame(info.var, rel.imp.all, info.imp)
    if ("chr" %in% colnames(var.imp.new)) {
        var.imp.new = var.imp.new[order(var.imp.new$chr, var.imp.new$pos),]
    }

    ## summarize errors
    info = cbind(run = 1:no.runs, info.error,
        min.imp = apply(imp.all, 2, min))

    ## write file
    if (!is.null(out.prefix)) {
      write.table(var.imp.new, file = paste(out.prefix, "_all_runs_relative.importance", sep = ""),
                  col.names = TRUE, row.names = FALSE, quote = FALSE)
      write.table(info, file = paste(out.prefix, "_all_runs.info", sep = ""),
                  col.names = TRUE, row.names = FALSE, quote = FALSE)
    } else {
      return(list(info = info, var.imp.rel = var.imp.new))
    }
}

#' Calculate error.
#'
#' This internal function calculates errors by comparing predictions of a test data set with the true values. 
#' For regression mode, it will give mean square error (mse) and pseudo R-squared (rsq).
#' 
#' @param rf randomForest object as generated by \code{\link{randomForest}} (Note: Function assumes that xtest and ytest were specified in the call so that the test component of rf is not NULL.)
#' @param true vector with true value for each sample in the test set
#' @param train.oob logical, if TRUE OOB samples are used for prediction of training data
#' 
#' @return vector with three elements (sensitivity, specificity, error) for classification
#' or two elements (mean square error, pseudo R-squared) for regression

.calculate.error <- function(rf, true, train.oob = TRUE) {
  
  ## extract predictions
  if (train.oob) {
    pred = rf$predicted
  } else {
    pred = rf$test$predicted
  }

  if (rf$type == "regression") {
    mse = sum( (pred - true)^2,na.rm = TRUE ) / sum(!is.na(pred))
    
    ## pseudo R-squared uses sum of squared differences divided by n instead of variance!
    v = sum( (true - mean(true))^2 ) / length(true)
    rsq = 1 - mse/v
    error = c(mse = mse, rsq = rsq)
  } else {
    err = sum(pred != true) / length(pred)
    conf = table(true = true, pred = pred)
    error = c(sens = conf[2, 2] / sum(conf[2,]),
              spec = conf[1, 1] / sum(conf[1,]), 
              error = err)
  }
  return(error)
}
